\section{Elevator}
\label{sec:ss_model_elevator}

\subsection{Continuous state-space model}
\index{FRC models!elevator equations}

The position and velocity derivatives of the elevator can be written as

\begin{align}
  \dot{x} &= v \label{eq:elevator_cont_ss_pos} \\
  \dot{v} &= a \label{eq:elevator_cont_ss_vel}
\end{align}

where by equation \eqref{eq:elevator_accel},

\begin{equation*}
  a = \frac{GK_t}{Rrm} V - \frac{G^2 K_t}{Rr^2 m K_v} v
\end{equation*}

Substitute this into equation \eqref{eq:elevator_cont_ss_vel}.

\begin{align}
  \dot{v} &= \frac{GK_t}{Rrm} V - \frac{G^2 K_t}{Rr^2 m K_v} v \nonumber \\
  \dot{v} &= -\frac{G^2 K_t}{Rr^2 m K_v} v + \frac{GK_t}{Rrm} V
\end{align}

Factor out $v$ and $V$ into column vectors.

\begin{align*}
  \dot{\begin{bmatrix}
    v
  \end{bmatrix}} &=
  \begin{bmatrix}
    -\frac{G^2 K_t}{Rr^2 m K_v}
  \end{bmatrix}
  \begin{bmatrix}
    v
  \end{bmatrix} +
  \begin{bmatrix}
    \frac{GK_t}{Rrm}
  \end{bmatrix}
  \begin{bmatrix}
    V
  \end{bmatrix}
\end{align*}

Augment the matrix equation with the position state $x$, which has the model
equation $\dot{x} = v$. The matrix elements corresponding to $v$ will be $1$,
and the others will be $0$ since they don't appear, so $\dot{x} = 0x + 1v + 0V$.
The existing rows will have zeroes inserted where $x$ is multiplied in.

\begin{align*}
  \dot{\begin{bmatrix}
    x \\
    v
  \end{bmatrix}} &=
  \begin{bmatrix}
    0 & 1 \\
    0 & -\frac{G^2 K_t}{Rr^2 m K_v}
  \end{bmatrix}
  \begin{bmatrix}
    x \\
    v
  \end{bmatrix} +
  \begin{bmatrix}
    0 \\
    \frac{GK_t}{Rrm}
  \end{bmatrix}
  \begin{bmatrix}
    V
  \end{bmatrix}
\end{align*}

\begin{theorem}[Elevator state-space model]
  \begin{align*}
    \dot{\mtx{x}} &= \mtx{A} \mtx{x} + \mtx{B} \mtx{u} \\
    \mtx{y} &= \mtx{C} \mtx{x} + \mtx{D} \mtx{u}
  \end{align*}
  \begin{equation*}
    \begin{array}{ccc}
      \mtx{x} =
      \begin{bmatrix}
        x \\
        v
      \end{bmatrix} &
      \mtx{y} = x &
      \mtx{u} = V
    \end{array}
  \end{equation*}
  \begin{equation}
    \begin{array}{cccc}
      \mtx{A} =
      \begin{bmatrix}
        0 & 1 \\
        0 & -\frac{G^2 K_t}{Rr^2 mK_v}
      \end{bmatrix} &
      \mtx{B} =
      \begin{bmatrix}
        0 \\
        \frac{GK_t}{Rrm}
      \end{bmatrix} &
      \mtx{C} =
      \begin{bmatrix}
        1 & 0
      \end{bmatrix} &
      \mtx{D} = 0
    \end{array}
  \end{equation}
\end{theorem}

\subsection{Model augmentation}

As per subsection \ref{subsec:u_error_estimation}, we will now augment the
\gls{model} so a $u_{error}$ term is added to the \gls{control input}.

The \gls{plant} and \gls{observer} augmentations should be performed before the
\gls{model} is \glslink{discretization}{discretized}. After the \gls{controller}
gain is computed with the unaugmented discrete \gls{model}, the controller may
be augmented. Therefore, the \gls{plant} and \gls{observer} augmentations assume
a continuous \gls{model} and the \gls{controller} augmentation assumes a
discrete \gls{controller}.

\begin{equation*}
  \begin{array}{ccc}
    \mtx{x}_{aug} =
    \begin{bmatrix}
      x \\
      v \\
      u_{error}
    \end{bmatrix} &
    \mtx{y} = x &
    \mtx{u} = V
  \end{array}
\end{equation*}

\begin{equation}
  \begin{array}{cccc}
    \mtx{A}_{aug} =
    \begin{bmatrix}
      \mtx{A} & \mtx{B} \\
      \mtx{0}_{1 \times 2} & 0
    \end{bmatrix} &
    \mtx{B}_{aug} =
    \begin{bmatrix}
      \mtx{B} \\
      0
    \end{bmatrix} &
    \mtx{C}_{aug} = \begin{bmatrix}
      \mtx{C} & 0
    \end{bmatrix} &
    \mtx{D}_{aug} = \mtx{D}
  \end{array}
\end{equation}

\begin{equation}
  \begin{array}{cc}
    \mtx{K}_{aug} = \begin{bmatrix}
      \mtx{K} & 1
    \end{bmatrix} &
    \mtx{r}_{aug} = \begin{bmatrix}
      \mtx{r} \\
      0
    \end{bmatrix}
  \end{array}
\end{equation}

This will compensate for unmodeled dynamics such as gravity. However, using a
constant voltage feedforward to counteract gravity is preferred over $u_{error}$
estimation in this case because it results in a simpler controller with similar
performance.

\subsection{Gravity feedforward}

Input voltage is proportional to force and gravity is a constant force, so a
constant voltage feedforward can compensate for gravity. We'll model gravity as
a disturbance described by $-mg$. To compensate for it, we want to find a
voltage that is equal and opposite to it. The bottom row of the continuous
elevator model contains the acceleration terms.

\begin{equation*}
  Bu_{ff} = -(\text{unmodeled dynamics})
\end{equation*}

where $B$ is the motor acceleration term from $\mtx{B}$ and $u_{ff}$ is the
voltage feedforward.

\begin{align*}
  Bu_{ff} &= -(-mg) \\
  Bu_{ff} &= mg \\
  \frac{G K_t}{Rrm} u_{ff} &= mg \\
  u_{ff} &= \frac{Rrm^2 g}{G K_t}
\end{align*}

\subsection{Simulation}

Python Control will be used to \glslink{discretization}{discretize} the
\gls{model} and simulate it. One of the frccontrol
examples\footnote{\url{https://github.com/calcmogul/frccontrol/blob/master/examples/elevator.py}}
creates and tests a controller for it.

\begin{remark}
  Python Control currently doesn't support finding the transmission zeroes of
  MIMO \glspl{system} with a different number of \glspl{input} than
  \glspl{output}, so \texttt{control.zero()} and
  \texttt{frccontrol.System.plot\_pzmaps()} fail with an error if Slycot isn't
  installed.
\end{remark}

Figures \ref{fig:elevator_pzmap_open-loop} through
\ref{fig:elevator_pzmap_observer} show the pole-zero maps for the open-loop
\gls{system}, closed-loop \gls{system}, and \gls{observer}. Figure
\ref{fig:elevator_response} shows the \gls{system} response with them.

\begin{bookfigure}
  \begin{minisvg}{3}{build/frccontrol/examples/elevator_pzmap_open-loop}
    \caption{Elevator open-loop pole-zero map}
    \label{fig:elevator_pzmap_open-loop}
  \end{minisvg}
  \hfill
  \begin{minisvg}{3}{build/frccontrol/examples/elevator_pzmap_closed-loop}
    \caption{Elevator closed-loop pole-zero map}
    \label{fig:elevator_pzmap_closed-loop}
  \end{minisvg}
  \hfill
  \begin{minisvg}{3}{build/frccontrol/examples/elevator_pzmap_observer}
    \caption{Elevator observer pole-zero map}
    \label{fig:elevator_pzmap_observer}
  \end{minisvg}
\end{bookfigure}

\begin{svg}{build/frccontrol/examples/elevator_response}
  \caption{Elevator response}
  \label{fig:elevator_response}
\end{svg}

\subsection{Implementation}

The script linked above also generates two files: ElevatorCoeffs.h and
ElevatorCoeffs.cpp. These can be used with the WPILib StateSpacePlant,
StateSpaceController, and StateSpaceObserver classes in C++ and Java. A C++
implementation of this elevator controller is available online\footnote{
\url{https://github.com/calcmogul/allwpilib/tree/state-space/wpilibcExamples/src/main/cpp/examples/StateSpaceElevator}}.
